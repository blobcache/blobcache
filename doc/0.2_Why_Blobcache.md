# Why Blobcache?

Blobcache is the simplest possible way to securely produce and consume storage as a resource.
You install Blobcache on a device, and it allows you to share the device's storage resources with other devices, or consume storage exposed by other devices.

## The Vision
Blobcache makes it easy for users to manage their own private storage network.

### As a Storage Producer
Users set up a fresh installation on a new server machine.
Something like a raspberry pi, or an old laptop with an external hard drive.
They then copy in their ssh key, install Blobcache, copy in their Blobcache key, and never have to install any other software on the machine.
All of their other Blobcache Nodes that need storage can connect securely to this new server and upload and download data.

### As a Storage Consumer
A user's application stores all of its state in Blobcache Volumes.
The application runs on the user's laptop and connects to a locally running Blobcache Node.
The application is configured to use specific Volumes on the Node, but it doesn't know or care about what backend
those Volumes are using.
The Blobcache Node on the laptop connects to other Blobcache Nodes to share and sync information.

Using a VPN like Tailscale, a user's devices can connect to each other from anywhere, with Blobcache, their data can be E2E encrypted at rest too.

## End-To-End Encryption (E2EE)

Blobcache's design choices encourage the construction of correct E2EE systems.

### Avoiding Information Leakage

#### Don't ask for Names
Any API, which asks for human readable names, is encouraging the leaking of information.
With conventional object storage APIs, client applications might be tempted to pass filenames or other useful information as an object key.
Additional metadata like a path, file mode, file size, or attributes could also be leaked to the storage provider.

Content-addresed stores don't allow clients to set keys, only values.
The key is assigned by hashing the value.
Clients post blobs and get back hashes.
That's an improvement from a key-value based API, since it removes one place to leak additional information.

#### Small Chunks Mandatory
Another improvement is a constraint on the size of an individual object.
In object storage, there is no practical upper limit on the size of a single object.
Blobs in Blobcache have a fixed maximum size, set at the Volume level.
That's good because large file sizes reveal a lot of information.
If an attacker wants to check for the existence of certain data, especially a single large file,
they can look for objects that are similarly sized.
If the file in question is exactly 123,456,789 bytes (123MB), then an encrypted object of exactly that size,
in a sea of differently sized encrypted objects, is conspicuous.
Forcing a smaller maximum size means that sizes are bound between 0 and the maximum size, which helps make the distribution more uniform.
A reasonable maximum size also means that an invidual blob will never take too long to hash, which means that hashes can be properly checked at read time to ensure integrity.


### Authenticated Encryption
Merely applying a cipher only helps maintain confidentiality.
To know that a given piece of data is authentic, it must also be authenticated.
This requires storing or sending an additional piece of information, usually 128 to 256 bits depending on the security level.

The best way to accomplish both of these things together is to use a scheme that encrypts the data and then computes a message authentication code (MAC) authenticating the cipher text.
These schemes are called "Encrypt Then MAC".

Content addressed stores eliminate the need for the MAC part, at least until the root of the data structure.
The only way to get data out of the content-addressed store is to know a Content Identifier (CID).
Knowing a CID means that the data can be verified, so it's impossible to be tricked into reading the wrong thing from a content-addressed store.
The CID takes care of authentication, any data structure built using CIDs as references is as authentic as the root is.

The root of the data structure (which lives in a Volume's cell), can be authenticated using encrypt-then-MAC, AEADs, or signing keys depending on the use case,
while the encryption strategy for all of the blobs (which live in the Volume's store) is the same.

### Vault Volumes
While the most efficient encryption strategies are implemented at the Application level, it is also possible to use a general purpose encryption strategy provided by Blobcache.
Vault Volumes present the same API as any other Volume, but all data in a Vault Volume is persisted in an encrypted form in another Volume.
A common pattern is to wrap a remote Volume in a vault Volume, to prevent the remote Node from having access to the Volume contents.

### More?
If a service is claiming to provide E2E encryption, but their API does much more than the Blobcache API, then the service is probably inviting information leakage.
There is just not that much more than can possibly be done (e.g. query filters, and read-modify-write operations) without complicated and prohibitively slow homomorphic encryption.

In contrast, if an application uses Blobcache for storage, you can be sure of E2EE by using the Vault Volume.
If the application uses it's own encryption strategy, then you only need to verify the confidentiality of the blobs and the authenticity and confidentiality of the root.
