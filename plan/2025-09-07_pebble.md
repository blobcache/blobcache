The local volumes in the `bclocal` implementation will be reimplemented using the Pebble databse, which is based on RocksDB.

The database will be broadly organized using 32 bit prefixes as table IDs.

```go
type tableID uint32

func appendTableID(out []byte, tid tableID) []byte {
    return binary.BigEndian.AppendUint32(uint32(tid))
}

func splitTableID(key []byte) (tableID, []byte, error) {
    if len(key) < 4 {
        return 0, nil, fmt.Errorf("key is too short to contain tableID")
    }
    return binary.BigEndian.Uint32(key[:4]), key[4:], nil
}
```

## Dependencies
The Env struct should be extended to add `PebbleDB *pebble.DB`, for now we will keep the existing `sqlx.DB` as `DB` and continue to use that for information other than local volumes and transactions.

## Tables
Several constants will be defined for the tables that we need.

```
const (
    tid_SYS_TXNS = iota

    tid_VOLUMES
    tid_VOLUME_LINKS
    tid_VOLUME_LINKS_INV
    tid_VOLUME_DEPS
    tid_VOLUME_DEPS_INV

    tid_BLOB_DATA
    tid_BLOB_INFO
    tid_LOCAL_VOLUME_TXNS
    tid_LOCAL_VOLUME_CELLS
    tid_LOCAL_VOLUME_BLOBS
)
```

All table keys discussed below are implicitly prefixed with the tableID.
By default, integers in the key should be big endian.
### BlobData
```
KEY:
    < 256 bit hash >
VALUE:
    < arbitrary blob data >
```

### BlobInfo
```
KEY:
    < 256 bit hash >

VALUE:
    < * optional 256 bit salt >
    < 32 bit ref count>
    < 32 bit size >
```
The BlobInfo table key is just the 256 bit hash.
The value starts with 1 byte of flags, which are used to determine the type of the value.
Nth bit refers to the least significant bits (masked by 1 << N).
If the 0th bit is set, then there is a 256 bit salt next in the value.
If the 1st bit is set, then the blob is large enough to store externally in the filesystem, and the next 2 bits matter.
If the 2nd bit is set then the blob was successfully uploaded.
If the 3rd bit is set then the blob is marked tombstoned, to be deleted.

The 2nd and 3rd bits are only used if the 1st bit is set.  If the 1st bit is not set, then these bits must be 0.
If the 1st bit is not set, then the blob is stored in the BlobData table.

After the flags, there is a 32 bit value fo the reference count.
After the possible salt and reference count is the size of the blob in bytes.

For now, we will never set bit 1.

## LocalVolumes
```
KEY:
    < 128 bit volume identifier >
VALUE
    < 32 bit max size >
    < 8 bit hash algorithm identifier >
    < LP string containing the schema >
```

## LocalTxns
```
KEY:
    < 128 bit transaction OID >

VALUE:
    < 64 bit version ID used for ordering >
    < 128 bit Volume OID >
```

LocalTxns stores the set of active mutating transactions.
Transactions target a single volume.
A unique 64 bit ID is used for ordering.

## LocalVolumeTxns
```
KEY:
    < 128 bit Volume OID >
    < 128 bit Transaction OID >

VALUE:
    < 64 Transaction version ID >
```

LocalVolumeTxns tracks the active transactions for a given volume, indexed by Volume.
When reading from a volume, the set of active transactions are excluded from reads.
For read only transactions, no entry needs to be made in this table.
Pebble's Snapshots will be used to provide a consistent view for reading.

## LocalVolumeCells
```
KEY:
    < 128 bit Volume OID>
    < 64 bit Version ID >

VALUE:
    < root data >

```
Values are the root data for the volume.
Reading the root data for the volume means reading the latest key for the volume which is not part of the active transaction set.

## LocalVolumeBlobs
```
KEY:
    < 128 bit Volume OID >
    < 256 bit Blob Hash >
    < 64 bit Version ID >
VALUE: 
    < 1 byte >
```

A non empty-value means the blob is being added.
An empty value means the blob is being deleted.

## VolumeLinks
```
KEY:
    < 128 bit Volume OID >
    < 128 bit Volume OID >
VALUE:
    < 64 bit ActionSet >
```
Volume links holds links from the first volume to the second volume.

## VolumeLinksInv
This table inverts the volume links table, showing which volumes have links to a given volume.
The key is simply the 2 volume OIDs from the other table in the reverse order.

## Notes
- Read-only transactions on local volumes should create and hold pebble's Snapshots to maintain a consistent view of the database.
Mutating transactions don't need to take a snapshot because they create an active entry in the database, so nothing will
cleanup rows they have written.
- On database startup the maximum version id is found by looking at the all of the volume cells.
This is stored in memory and incremented atomically for new mutating transactions.
- There is no migration of active databases to worry about.
- LPStrings are length prefixed strings, they can be Appended and Read using functions from the sbe package.
- Large Blobs will eventually be stored in the filesystem outside of the database.
For now everything can go in the blobs table.
- The latest versionID can be determined by scanning the Volume cell table.
- ActionSets can be treated as opaque 64 bit integers and copied around blindly.
- For now don't worry about garbage collecting blobs.

