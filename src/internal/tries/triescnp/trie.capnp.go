// Code generated by capnpc-go. DO NOT EDIT.

package triescnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Entry capnp.Struct

// Entry_TypeID is the unique identifier for the type Entry.
const Entry_TypeID = 0x9fb6af56de709433

func NewEntry(s *capnp.Segment) (Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Entry(st), err
}

func NewRootEntry(s *capnp.Segment) (Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Entry(st), err
}

func ReadRootEntry(msg *capnp.Message) (Entry, error) {
	root, err := msg.Root()
	return Entry(root.Struct()), err
}

func (s Entry) String() string {
	str, _ := text.Marshal(0x9fb6af56de709433, capnp.Struct(s))
	return str
}

func (s Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Entry) DecodeFromPtr(p capnp.Ptr) Entry {
	return Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Entry) Key() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Entry) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Entry) SetKey(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Entry) Value() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Entry) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Entry) SetValue(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// Entry_List is a list of Entry.
type Entry_List = capnp.StructList[Entry]

// NewEntry creates a new list of Entry.
func NewEntry_List(s *capnp.Segment, sz int32) (Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Entry](l), err
}

// Entry_Future is a wrapper for a Entry promised by a client call.
type Entry_Future struct{ *capnp.Future }

func (f Entry_Future) Struct() (Entry, error) {
	p, err := f.Future.Ptr()
	return Entry(p.Struct()), err
}

type Node capnp.Struct

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xd7716cf897996ddc

func NewNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node(st), err
}

func NewRootNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node(st), err
}

func ReadRootNode(msg *capnp.Message) (Node, error) {
	root, err := msg.Root()
	return Node(root.Struct()), err
}

func (s Node) String() string {
	str, _ := text.Marshal(0xd7716cf897996ddc, capnp.Struct(s))
	return str
}

func (s Node) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node) DecodeFromPtr(p capnp.Ptr) Node {
	return Node(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node) Entries() (Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Entry_List(p.List()), err
}

func (s Node) HasEntries() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Node) SetEntries(v Entry_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewEntries sets the entries field to a newly
// allocated Entry_List, preferring placement in s's segment.
func (s Node) NewEntries(n int32) (Entry_List, error) {
	l, err := NewEntry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Node_List is a list of Node.
type Node_List = capnp.StructList[Node]

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Node](l), err
}

// Node_Future is a wrapper for a Node promised by a client call.
type Node_Future struct{ *capnp.Future }

func (f Node_Future) Struct() (Node, error) {
	p, err := f.Future.Ptr()
	return Node(p.Struct()), err
}

type Index capnp.Struct

// Index_TypeID is the unique identifier for the type Index.
const Index_TypeID = 0xba9cf241dfa2755b

func NewIndex(s *capnp.Segment) (Index, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Index(st), err
}

func NewRootIndex(s *capnp.Segment) (Index, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Index(st), err
}

func ReadRootIndex(msg *capnp.Message) (Index, error) {
	root, err := msg.Root()
	return Index(root.Struct()), err
}

func (s Index) String() string {
	str, _ := text.Marshal(0xba9cf241dfa2755b, capnp.Struct(s))
	return str
}

func (s Index) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Index) DecodeFromPtr(p capnp.Ptr) Index {
	return Index(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Index) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Index) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Index) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Index) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Index) Ref() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Index) HasRef() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Index) SetRef(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Index) Prefix() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Index) HasPrefix() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Index) SetPrefix(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Index) Count() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Index) SetCount(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Index) IsParent() bool {
	return capnp.Struct(s).Bit(64)
}

func (s Index) SetIsParent(v bool) {
	capnp.Struct(s).SetBit(64, v)
}

// Index_List is a list of Index.
type Index_List = capnp.StructList[Index]

// NewIndex creates a new list of Index.
func NewIndex_List(s *capnp.Segment, sz int32) (Index_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Index](l), err
}

// Index_Future is a wrapper for a Index promised by a client call.
type Index_Future struct{ *capnp.Future }

func (f Index_Future) Struct() (Index, error) {
	p, err := f.Future.Ptr()
	return Index(p.Struct()), err
}

const schema_86dd963ad5de13d5 = "x\xda\\\x91\xbfk\x13a\x18\xc7\xbf\xdf\xe7\xbd\x98\x84" +
	"p\x92\xe32*\xa2D\xd0!\xe2\xaf)K\xa2\xe0\xa0" +
	"\x83\xe4]\x04Q\xc1#y\x83\x87\x97\xcby\xb9h2" +
	"\x88(\xe8\x90Y\x94B\xa1\xd0\x7f\xa0[\x87\xfe\x13\x9d" +
	"B\x976\x1d\xbbw\xeav\xe5\x12\x92\xb6\xd9\x9e\xf7\xe1" +
	"\xc3\xe7\xf9\xc0[\xdeoZ\x8f\xec\xbe@\xf4\x8d\xdc\xb5" +
	"\xf4\xc9\xdfh\xf6fgw\x0bN\x89\xe9\xd4\x9dM\xeb" +
	"\xff\x8e\xfe 'y\xc0\xbd\xc9\x89{\x97\xd9t\x9b\xdf" +
	"\xc0\xf4\xddp\xfb\xf8\xd9\xe9\xe6\x1et\x89\xb2\x0e\x7f\xe7" +
	"\xc4\xfd=\x87\x7f\xf2\x04L\x0f{\x1b\xff\xcf\x82/\x07" +
	"k\xe29\xf1V~\xb9\x1fd15PK\x93\xd87" +
	"\x0f\xda^\xc40\xaa\xbf\x08\x93x\x0c\xb4H]P\x16" +
	"`\x11p\xee\xdf\x01tUQ?\x14:d\x85\xd9\xb2" +
	"\xf6\x18\xd0\xf7\x14\xf5Sa\xfe\xb3\x19\xd3\x86\xd0\x06o" +
	"}\xf5\x82\xa1Y\xbe\xae\xc8_\x86\x1d3Z\xc8\xcb+" +
	"\xb9\x97\xc9\xdf+\xeaO\x97\xe4\xa6\x0e\xe8\x8f\x8a:\x10" +
	"R*\x14\xc0\xf1\xb3\x83\x1dE\x1d\x09\x1d\xd5\xacP\x01" +
	"N\xef\x15\xa0\x03E=\x12\xe6c\xd3]\xdemD\xb1" +
	"\xe9\xfa\xa3UT\xbb?\x0c\x13\x16!,\x82\xa9?h" +
	"y\xb1\x09\x13\x00$\x84\\\x0b}\xdd\xef\x98y\xa6\xb5" +
	"\xca\xb4\x9f\x03\xba\xa0\xa8\xab\xc2\x1f&\xcc\xe8\x01\xaf\x83" +
	"-E\x96/\xfe\x11\xcc\x96\xe7\x01\x00\x00\xff\xff\xc2\xf6" +
	"i\xf7"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_86dd963ad5de13d5,
		Nodes: []uint64{
			0x9fb6af56de709433,
			0xba9cf241dfa2755b,
			0xd7716cf897996ddc,
		},
		Compressed: true,
	})
}
