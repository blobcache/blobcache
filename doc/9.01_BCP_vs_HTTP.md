# BCP vs HTTP

This article comparse Blobcache Protocol (BCP) to [HyperText Transfer Protocol (HTTP)](https://en.wikipedia.org/wiki/HTTP).

## What is HTTP?
HTTP is a protocol for serving a set of documents over the network.
Documents are identified by paths e.g. `/index.html` or `/widgets/012345.json`.

HTTP is loosely a request response protocol.
The client sends a stream of bytes as a request, and the server sends a stream of bytes as a response.
These streams are called the "body" of the request and response.
The server can start sending bytes whenever, and in theory both the request and response can be arbitrarily long.
In practice there are lots of problems associated with long requests and responses and so there is almost always a maximum length.

HTTP requests also contain a method, which can convey some semantics, although in practice this is set somewhat arbitrarily.

HTTP allows both the client and server to include aribtrary key value pairs of strings, called "headers" with the request and response.
Headers are sent before the body, and contain things like format, compression information, cachability of the data, and authentication and authorization information.

## What is BCP?
BCP is a protocol for exposing content-addressable storage over the network as logical units called Volumes.
Volumes contain a small amount of mutable data in their root cell, and much larger amount of immutable data as blobs in a content addressed store.
BCP is also request and response based, but requests and responses are never much larger than the largest single blob in the system.
The client always talks first, finishes talking, and then the server responds.
Requests and responses are considered single messages, not streams.

## Comparison

### Caching
With HTTP caching is usually managed with headers.
There are special headers which say if something can be cached and for how long.
Sometimes there is even a hash included which can be used to quickly determine if a larger value has changed.
Caching can specify a time frame, but any document can include any headers, and change them at arbitrary times.
When this breaks the clients assumptions, it can lead to hard-to-catch bugs that are only resolved by flushing the cache.

Blobcache has a less configurable, but also less complicated approach to caching which *Just Works*.
Everything immutable can be cached forever, everything mutable cannot be cached at all.

### Mutability
With HTTP documents there is no way to tell what is supposed to be immutable vs. mutable.
Sometimes there are hints in the headers, but in principle any document can change at any time, and choices about which documents can be changed and which cannot are entirely up to the application.

With Blobcache Volumes: roots are always mutable, all calls to `Load` retrieve the volume root, and never a cached version.
All blobs are immutable, they have their cryptographic content identifier `CID`.
They can be cached forever, and never need to be redownloaded once they exist locally.

The only way to request a blob is by its `CID`, with HTTP: paths are arbitrary and any of them could contain a mutable resource.
You can't lie about the relationship between data and its `CID`; either it matches or it doesn't.
A server returning the wrong blob will always be detected by the client and treated the same as corruption.

### Security
BCP is built on top of QUIC.
It uses UDP sockets for communication.
Unlike HTTP, which can run on top of TCP or TLS, BCP only runs on QUIC.

QUIC provides security using the same technology as TLS1.3.
TLS allows a large space of possible authentication chains, but BCP restricts this to a single self-signed certificate.
All communication with BCP is between 2 well defined identities, both the client and the server know exactly who is on the other end.

The choice of only self-signed certificates presents a much simpler trust model to users.
Most users don't realize the trust assumptions that they are making.
The typical user makes connections based on the following trust model:
> "The people who maintain my operating system said that this particularly trust worthy company said that this public key is allowed to act as this domain name".

A simpler model is:
> "I know the person or device that gave me this public key, so connections from it are really coming from that user or device".

PeerIDs are derived by hashing the public key presented by the counter-party to authenticate. 
Blobcache uses PeerIDs throughout to make authorization decisions.
They can also be specified in the GROUPS configuration file used by blobcache.

HTTP 1.x is usually run over TLS (`https://`).
Newer versions of HTTP can also run over QUIC.
Browsers produce a lot of fear and doubt when they encounter a self-signed cert, and so it is annoyingly difficult to establish secure connections between machines on local networks.
One option is to involve a 3rd party company to prepare a blessed certificate that the browser will accept.
Another option is to create a certificate authority and distribute its certificate to all the devices too.
Now you have 2 certificates, and if you're not careful, a way for an attacker to impersonate any domain name, instead of just a local machine.

BCP is always run over QUIC and connections are always mutually authenticated.
The configuration story is similar to SSH, where operators can copy and paste public key information into some config files and call it a day.

### Wire Format
Early versions of HTTP are text based protocols.
Newer versions are binary protocols.

BCP is a binary protocol.
This makes it efficient for transferring data.
The data does not have to be transcoded into hex or base64.

There is almost no additional information sent when uploading or downloading data: just the `OID` of the transaction that the data is going to, or the `CID` of the blob being requested.

### Errors
HTTP allows certain errors to be expressed at the protocol level, although in practice useful diagnostic information must be conveyed in the response body.
Errors are indicated in the status code sent before the response.

BCP includes a code in every message as well.
BCP uses the status code to parse a structured error message from the wire.

There are only so many things that can go wrong when handling a BCP request:
- The client isn't allowed to perform the action: either creating a volume or starting a transaction.
- A handle the client has presented is invalid.
- The client is trying to perform a transaction operation which is not valid for that kind of transaction.
- The request timed out.
- A blob is too large for the Volume that it is being posted to.
- A new volume root does not conform to the Volume's schema.
- An internal error occured.  Something happened, the server couldn't fulfill the request.