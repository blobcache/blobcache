# Volumes vs Files

Files present the user with an arbitrarily long sequence of bytes.
The user can append to the end, shorten the file, or replace arbitrary sub sequences.
Directories organize a mapping from unique names to files and other directories.

Volume store data, and Volumes can link to other Volumes.
The equivalent in a Filesystem would be an object that simultaneously performs both the functions of a file and a directory.

## Schemas vs. Directories

Volumes that link to other volumes usually have a Schema that creates a listing of names similar to a directory.
In a filesystem there is one kind of directory, provided by the system.
The user can't extend or change it, to create a directory with different semantics.
With Volumes, the user brings their own "directory" format.
Blobcache provides a way for users to indicate that one Volume links to another, the linked volume will not be cleaned up until the parent volume is cleaned up first.

By default, the current implementation of Blobcache uses the `BasicNS` (Basic Namespace) Schema, to organize the root Volume like a directory in a filesystem.
When the user runs the `lsvol` or `mkvol.local` commands (which you can read about in the [CLI Referene](./8.00_CLI_Reference.md)) they are using the `BasicNS` schema to manage the data structure in the Volume.

## State Representation

The major difference between Volumes and Files is how they force the user to think about state.
A File forces the user to take all of the state they want to persist in the file, and organize it in a sequence.
Each bit of state has to be ordered just before and just after some other bit, except for the first and last bits.

A Volume does not require this.
A Volume allows the user to represent an arbitrary data structure, provided it does not have reference cycles.
Everywhere there would be pointer, there is instead a hash reference (`CID`) to another blob.
If the user application has a tree, then the Volume can contain a tree just as easily.
If the user application has a DAG, then the Volume can also contain a DAG.

## Deduplication

Consider the situation where one application produces a file (like a photo), and another application wants to read the file (to send in chat).
There are basically 2 ways to go about this.
The first way is to record the filepath in the messaging app. Then whenever the messenger needs it, it asks the filesystem for the file at that path, and reads it in again.
A benefit of this approach is the file doesn't need to be copied, so some space is saved.
A problem with this approach is that any edits to the file in the Photos app (like filters) will also show up in the messenger app, but only for the local user.
The other users will have had to download their own copy of the photo, and there is no way for that to be edited.

A better solution is to make a copy of the file, then the messenger has it's own copy, which reflects the reality that the remote messengers would not observe any changes made to the local file.
Just like the messenger would not observe changes that the Photos app makes.
The downside to this approach is that if the file is large, then it costs more space to make a copy, perhaps prohibitively more.

Content addressed storage solves this problem.
Each blob is only stored once across all of Blobcache, even if many Volumes contain the same blobs, they will only be stored once.
Two applications built on Blobcache, could hand off files using the following system.
1. Application A opens a transaction on a volume, traverses the datastructure until it gets to the root of the File.
2. Application A opens a new transaction on the same volume, but with reduced permissions.  The Volume cell cannot be read, but blobs can still be retrieved.
The transaction handle and the volume root are sent to Application B
3.  Application B uses the root of the file and the transaction handle to pull blobs into it's own volume, and stores the root of the file somewhere in the application's data structure.


