# Introduction to Blobcache

Blobcache is a system for exposing storage as a resource over the network.
If you have a server, or a desktop, or an old laptop, or a cloud VM, or whatever, then you can expose storage from that device to your other devices.
Blobcache handles authentication, encryption in transit, and authorization.
Blobcache makes it easy for the device providing the storage to be outside the security perimeter of the devices using the storage (E2EE).

Sharing a blobcache volume or a set of volumes with a new device is a single line change in a configuration file.

## Nodes
A single running instance of Blobcache is called a Node.
Each node is identified by it's own public key.
Nodes mediate access to a set of Volumes.

Nodes use a single UDP port to speak the Blobcache (QUIC based) protocol to other Nodes.
They also typically serve an API on a unix socket for local applications to use.

Nodes do not participate in any public distributed hash tables or ledgers, and the outbound connections will all be the result of user action.
Inbound connections will only be accepted from peer Nodes which have been granted access to one of the volumes.

## Volumes
Volumes are the central concept in Blobcache.
A Volume holds a rooted hash-linked data structure.
A Node can have any amount of Volumes.

Volumes consist of 2 parts:
1. A root cell, which can hold a small number of bytes (about 1MB, half of a blob).
2. A content-addressed store which can hold an unlimited amount of blobs, addressed by a cryptographic hash of their contents.

The cryptographically assigned address is called a *Content Identifier* (CID).
The CID is 256 bits long, and is used to retreive that data from the store.
The hash function and maximum blob size are configurable per volume.
The default blob size is about 2MB, and the default hash function is BLAKE3.

Volumes are identified using a 128 bit randomly generate object identifier (OID).

### Backends
Each Volume has a backend configuration, which specifies how the data will be stored.
The simplest configuration is the *Local* backend.
Local Volumes store data in the node's SQLite3 database on the local filesystem.

Some other possible backends
- Git.  Stores the contents of the Volume in a Git repository.
- Remote.  Refers to a Volume on another Blobcache Node.
- RootAEAD.  Encrypts volume root with an AEAD, but leaves the blobs unencrypted.
This is good for Schemas which manage their own encryption keys with their other data.
- Vault.  Encrypt all of the blobs, and the root, and create a new tree that references all of the blobs, and store that as the new root.

## Transactions
Volumes are viewed and mutated in transactions.
To do anything with a Volume, you first begin a Transaction on that Volume.

Transactions, like volumes, are identified by 128 bit identifiers.
Transactions can expire if inactive.
Transactions are either mutating  or viewing transactions.
Any amount of readers can simultaneously view a volume, but only one writer can mutate the volume at a time.
The writer will not block readers, and the readers do not block the writer or one another.

All transactions end in either a Commit or an Abort.
View transactions are only allowed to end in an Abort.
When a transaction is Commited, a new root for the Volume must be provided.
Committing a transaction atomically adds or deletes any blobs that have changed, and updates the root.
One consistent data structure replaced with another.

## Schemas
Schemas are the set of rules that define the data structure in a Volume and how it is allowed to change.

Most Schemas are enforced at the Application level, and Blobcache assumes no knowledge of the Schema by default.  There are some Schemas which Blobcache is aware of, and they are used for certain features.

### Namespaces
Each Blobcache Node has a Namespace associated with it.
Namespaces assign names to Volumes.
The Namespace is from the perspective of the Node, and is not globally coordinated in any way.
Namespace are implemented as a Schema, which Blobcache knows how to interpret.
All the entries in a namespace are stored in a Volume.

Volumes expire by default, which is useful for Applications that only need to tempoarily access a Volume.
Adding a Volume to the Node's Namespace will cause the Volume to be persisted until it is removed.
