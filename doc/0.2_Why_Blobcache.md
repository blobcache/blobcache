# Why Blobcache?

Blobcache is the simplest possible way to securely produce and consume storage as a resource.
You install Blobcache on a device, and it allows you to share the device's storage resources with other devices, or consume storage exposed by other devices.

## The Vision

### As a Storage Producer
Users set up a fresh installation on a new server machine.
Something like a raspberry pi, or an old laptop with an external hard drive.
They then copy in their ssh key, install Blobcache, copy in their Blobcache key, and never have to install any other software on the machine.
All of their other Blobcache Nodes that need storage can connect securely to this new server and upload and download data.

### As a Storage Consumer
A user's application stores all of its state in Blobcache Volumes.
The application runs on the user's laptop and connects to a locally running Blobcache Node.
The Node on the laptop connects to other Blobcache Nodes to share and sync information.

The application doesn't particularly care where the Volumes are.

The application is just written against the Blobcache Volume API.
The user is able to choose any Volume backend.

Using a VPN like Tailscale, their devices can connect to each other from anywhere, with Blobcache, their data can be E2E encrypted at rest too.

## End-To-End Encryption (E2EE)

Blobcache's design choices encourage the construction of correct E2EE systems.

### Avoiding Information Leakage

Any API, which asks for human readable names, is encouraging the leaking of information.
With conventional object storage APIs, client applications might be tempted to pass filenames or other useful information as an object key.
Additional metadata like a path, file mode, file size, or attributes could also be leaked to the storage provider.

Content-addresed stores don't allow clients to set keys, only values.
The key is assigned by hashing the value.
Clients post blobs and get back hashes.
That's an improvement from a key-value based API, since it removes one place to provide additional information.

Another improvement is a constraint on the size of an individual item.
In object storage, there is no practical upper limit on the size of a single object.
Blobs in Blobcache have a fixed maximum size, set at the volume level.
That's good because large file sizes reveal a lot of information.
Forcing a smaller maximum size means that sizes are bound between 0 and the maximum size, which helps make the distribution more uniform.
A reasonable maximum size also means that an invidual blob will never take too long to hash, which means that hashes can be properly checked at read time to ensure integrity.

### Authenticated Encryption
Merely applying a cipher only helps maintain confidentiality.
To know that a given piece of data is authentic, it must also be authenticated.
This requires storing or sending an additional piece of information, usually 128-256 bits depending on the security level.

The best way to accomplish both of these things together is to use a scheme that encrypts the data and then computes a message authentication code (MAC) authenticating the cipher text.
These schemes are called "Encrypt Then MAC".

Content addressed stores eliminate the need for the MAC part, at least until the root of the data structure.
Since the only way to get data out of the content-addressed store is to know a Content Identifier (CID).
The CID takes care of authentication, any data structure built using CIDs as references is as authentic as the root is.

The root of the data structure (which lives in a Volume's cell), can be authenticated using conventional encrypt-then-MAC, or signing keys depending on the use case,
while the encryption strategy for all of the blobs (which live in the Volume's store) is the same.
